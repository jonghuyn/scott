# Apache Kafka

## 개요

### 메시지
- 카프카에서는 데이터의 기본 단위를 **메시지(message)라고** 한다. 메시지는 바이트 배열의 데이터로 간주되어 특정 형식이나 의미를 갖지 않는다.
- 데이터베이스의 행이나 레코드에 비유될 수 있다.
- 카프카의 메시지 데이터는 토픽으로 분류된 파티션에 수록되는데, 데이터를 수록할 파티션을 결정하기 위해 일관된 해시값으로 키를 생성하므로, **같은 키를 값는 메시지는 항상 같은 파티션에 수록**된다.
### 스키마
- 카프카는 메시지를 단순한 배열로 처리하지만, 메시지의 구조를 나타내는 **스키마(Schema)를** 사용할 수 있다.
- JSON, XML 등 필요에 따라 여러가지 표준 형식을 사용할 수 있지만, 가장 많이 사용하는 형식은 **하둡(Hadoop)을** 위해 개발된 직렬화 프레임워크인 Avro이다.
### 토픽과 파티션
- 카프카의 메시지는 **토픽(topic)으로** 분류된다. 토픽은 데이터베이스 테이블이나 파일 시스템의 폴더와 유사하다.
- 하나의 토픽은 여러개의 파티션으로 구성될 수 있다.
<img src="/resources/relatedTech/apacheKafka/img_kafka_topic.png" alt="kafka_topicStructure" />*Fig. 토픽의 구조를 나타냄. 메시지의 처리 순서는 토픽이 아닌 파티션 별로 유지 관리 된다.*
- 파티션은 여러 서버에 걸쳐서 분산될 수 있다. 즉, 하나의 토픽이 여러 서버에 걸쳐 수평적으로 확장이 가능하다.
### 프로듀서와 컨슈머
#### 프로듀서
- **프로듀서(Producer)는** 새로운 메시지를 생성하며, 메시지는 특정 토픽으로 생성된다.
- 기본적으로 프로듀서는 메시지가 어떤 파티션에 수록되는지 관여하지 않지만, 프로듀서가 메시지 키와 파티셔너(partitioner)를 이용하여 특정 파티션에 메시지를 직접 쓰는 경우가 있다.
#### 컨슈머
- **컨슈머(Consumer)는** 하나 이상의 토픽을 구독하여 메시지를 생성된 순서로 읽으며, 메시지의 오프셋(offset)을 유지하여 읽는 메시지의 위치를 알 수 있다.
- 하나의 토픽을 여러 컨슈머가 읽을 수 있는데, 이처럼 하나의 토픽을 읽기 위한 컨슈머들을 **컨슈머 그룹(Consumer Group)이라고** 한다.
<img src="/resources/relatedTech/apacheKafka/img_kafka_consumerGroup.png" alt="kafka_consumerGroup" />*Fig. 한 토픽에 담긴 메시지를 읽기 위해 같은 그룹의 여러 컨슈머가 함께 동작하며, 한 토픽의 각 파티션은 하나의 컨슈머만 소비할 수 있다.*
- 파티션에 수록된 메시지는 **고유한 오프셋**을 갖고 있어서 컨슈머가 메시지를 읽다가 중단해도, 그 다음 메시지부터 읽을 수 있다.
### 브로커와 클러스터
#### 브로커
- 하나의 카프카 서버를 **브로커(Broker)라고** 한다.
- 브로커는 프로듀서로부터 메시지를 수신하고 오프셋을 지정한 후, 해당 메시지를 디스크에 저장한다. 
- 또한, 컨슈머의 파티션 읽기 요청에 응답하고 디스크에 수록된 메시지를 전송한다.
#### 클러스터
- 카프카의 브로커는 **클러스터(Cluster)의 일부로** 동작된다. 즉, 여러 개의 브로커가 하나의 클러스터에 포함될 수 있으며, 그 중 하나의 브로커가 클러스터 컨트롤러의 기능을 수행하도록 자동으로 선정된다.
- 컨트롤러는 클러스터 내부의 각 브로커에게 담당 파티션을 할당하고, 브로커들이 정상적으로 동작하는지 모니터링하는 **관리 기능**을 맡는다.
### 기존 메시징 시스템과의 차이
- RabbitMQ나 ActiveMQ와 같은 기존의 메시징 시스템에서는 브로커(Broker)가 컨슈머(Consumer)에게 메시지를 푸시(push)해주는 방식이었는데, 카프카는 컨슈머가 브로커로부터 메시지를 직접 가져가는 **풀(Pull)** 방식으로 동작한다.
- 이 구조로 인해 컨슈머는 자신의 처리 능력만큼만 메시지를 가져오기 때문에 과부하(OverLoad)를 방지 및 최적의 성능을 낼 수 있다.
<img src="/resources/relatedTech/apacheKafka/img_kafka_pullpush.png" alt="kafka_pull_push" />*Fig. 프로듀서는 브로커로 메시지를 푸시(push)하고, 컨슈머는 브로커로부터 메시지를 풀(pull) 함*